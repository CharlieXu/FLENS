//
// compile with:
/*
 clang++ -std=c++0x -DWITH_REFBLAS -c -DCHECK_CXXLAPACK test_lahqr.cc  -I../../
 gfortran test_lahqr.o -lstdc++ ilaenv.o iparmq.o drivers.o ../lapack/interface/cblas_REF.a ../lapack/interface/blas_REF.a ../lapack/interface/lapack_FLENS.a

*/

#include <iostream>

#include <flens/lapack/interface/include/config.h>

#include <flens/flens.cxx>

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------

using namespace std;
using namespace flens;

// typedef mpf_class   T;

typedef double   T;


#define CASE1

int
main()
{
    typedef GeMatrix<FullStorage<T, ColMajor> >   GeMatrix;
    typedef GeMatrix::IndexType                   IndexType;

    typedef DenseVector<Array<T> >                DenseVector;

    const Underscore<IndexType> _;

#   if defined(CASE1)
    const IndexType n = 5;
#   endif

    bool                wantT = true, wantZ = true;
    IndexType           iLo = 1, iHi = n;
    IndexType           iLoZ = 1, iHiZ = n;

    GeMatrix            H(n, n), Z(n, n);
    DenseVector         wr(n), wi(n);


#   if defined(CASE1)
    H = -0.060995858283363880991689853772186324931681156158447265625, -0.47217493390263653996186121730715967714786529541015625,  -0.87520034306030447535107441581203602254390716552734375, -0.5816219193872826931368535952060483396053314208984375,    0.239763159714493967467063839649199508130550384521484375,
        -0.66119583846837770568782843838562257587909698486328125,      0.049372479809657032756575745224836282432079315185546875, -0.5403983141779473697852154145948588848114013671875,     -0.897939096884550647104106246843002736568450927734375,    -0.8049117981610274252801673355861566960811614990234375,
         0.442537213927424011306044349112198688089847564697265625,    -0.3190462887113898471369566323119215667247772216796875,   -0.68811714644737220769599161940277554094791412353515625,  0.021001739424070076101003223811858333647251129150390625, -0.07339212397269323506776572685339488089084625244140625,
         0.33831406532446006707459673634730279445648193359375,        -0.371747337835730495836372710982686839997768402099609375,  0.20477025579469410043742527705035172402858734130859375, -0.5101915027168166805182636380777694284915924072265625,   -0.0183190079043256959234753367127268575131893157958984375,
         0.328301140317736994678199380359728820621967315673828125,     0.399693408928155802239956528865150175988674163818359375, -0.35164558068446893912550876848399639129638671875,       -0.01327504009134028439831354262423701584339141845703125,   0.2371041543536089035715264117243350483477115631103515625;

    Z =  1,  0,                                                         0,                                                         0,                                                       0,
         0, -0.410360420391090219283114493009634315967559814453125,     0.349438973804838848291609565421822480857372283935546875,  0.6081471539370644219246742068207822740077972412109375, -0.58279822247577028893061878989101387560367584228515625,
         0, -0.6241369710733835063365404494106769561767578125,         -0.386250582179081980438439813951845280826091766357421875, -0.5630989599591778027587452015723101794719696044921875, -0.3797144853683553922252258416847325861454010009765625,
         0, -0.477144767395224267403364137862809002399444580078125,     0.69104199865988824580398386387969367206096649169921875,  -0.26478356595799523720557999695301987230777740478515625, 0.4740079010249431679113740756292827427387237548828125,
         0, -0.463022934273397857030118984766886569559574127197265625, -0.5011624960436369402572154285735450685024261474609375,    0.4929160817519642190376316648325882852077484130859375,  0.5398885544688416526781793436384759843349456787109375;
#   endif

    cerr << "H = " << H << endl;
    cerr << "Z = " << Z << endl;

    DenseVector tau(n-1);
    DenseVector work;

    IndexType info = lapack::lahqr(wantT, wantZ, iLo, iHi, H, wr, wi, iLoZ, iHiZ, Z);

    cerr << "H = " << H << endl;
    cerr << "Z = " << Z << endl;
    cerr << "info = " << info << endl;
}
